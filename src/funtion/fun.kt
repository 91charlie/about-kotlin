
fun f_ex(a:Int , b:Int = 4 ) : Int = a + b
// 함수 선언의 기본적 형태이며 return 값이 간단한 연산값일 경우 " = " 을 사용하여 본 예시의 "a + b" 처럼 작성하면 간결한 표현이 가능하다.
// 예시의 "b" 처럼 기본값을 가진 파라미터가 있을 경우 기본값이 없는 파라미터를 먼저 작성하여 함수 선언을 한다.

// @JvmOverloads 는 코틀린과 자바의 상호 운용성을 높혀주는 어노테이션이다.
@JvmOverloads
fun j_ex(a:Int, b:Int = 3):Int = a + b
//기본 매개변수 (default parameter) 의 각 값을 삽입하는 오버로드 된 메서드가 자동으로 생성된다.
// 코틀린에서 작성된 코드를 기본 매개 변수가 없는 자바에서 사용가능해진다.
// 오버로딩? -> 같은 이름의 메소드를 매개 변수의 타입과 개수를 달리하여 선언하는 것


fun Int.double():Int = this * 2

fun Int.half():Int = this / 2
// fun 확장하려는 타입.이름:리턴 타입 으로 확장 함수 선언이 가능하다
// 내용은 다른 함수와 동일하게 = 또는 {}내에 작성하면 된다.
// 오버라이딩하여 기능을 재정의 할 수 없다.
// 오버라이딩? -> 부모클래스의 메소드를 자식클래스에서 재정의 하는 것 (상속 관계가 중요하다.)

// 확장 프로퍼티와 확장 함수를 함께 사용한 예시
val Int.v_ex:Int // <-- 제곱 연산을 수행하는 확장 프로퍼티를 선언
    get()=this * this
fun Int.fv_ex():Int { // <-- 해당 함수를 호출할 경우 프로퍼티에서 연산된 값을 함수내에서 이용하게 된다.
    println("${this}의 제곱은 ${this.v_ex} 입니다.")
    return v_ex
}
//확장 프로퍼티는 "계산된 값"을 제공하고, 확장 함수는 "그 값을 활용하는 기능"을 수행하도록 설계하면 가장 효율적이다




fun main()
{
    f_ex(4)
    j_ex(3)

    val a:Int = 4

    println(5.double())
    println(6.half())


    a.fv_ex()
}